:::::::::::::::

proc
   freq

proc in time
   freq -> bi

:::::::::::::::

transport
   play( implicit source: TimeSource )

that would mean we create a possibly infinite chain of signification here as well! that means there is a re-entry of p time

:::::::::::::::

BiSource[ S <: Sys[ S ], A ] {
   def get( implicit tx: S#Tx, time: TimeSource[ S ]) : A
}

BiSink[ S <: Sys[ S ], A ]
   def set( value: A )( implicit tx: S#Tx, time: TimeSource[ S ]) : Unit
}

BiVar extends BiSource with BiSink

that is to say, no mention of Expr in Bi's type parameter A

:::::::::::::::

object Bi {
   trait Var[ S <: Sys[ S ], A ] extends Bi[ S, A ] with BiVar[ S, Expr[ S, A ]]
}
trait Bi[ S <: Sys[ S ], A ] {
   def projection( implicit tx: S#Tx, time: TimeSource[ S ]) : Expr[ S, A ]
   def value( implicit tx: S#Tx, time:  TimeSource[ S ]) : A
   def changed: EventLike[ S, Bi.Update[ S, A ], Bi[ S, A ]]
}

:::::::::::::::

valueSpan( time: Long ) : (Long, A)

:::::::::::::::

the problem of Chronus is that most likely that would be a Transport, and that in turn can not be serialized _along with chronus_, because that essentially depends on system thus, i.e. must be a live view

:::::::::::::::

so let's rethink --- as simple as possible first:

trait BiExpr[ S <: Sys[ S ], A ] {
   def projection( time: Expr[ S, Long ])( implicit tx: S#Tx ) : Expr[ S, A ]
   def valueAt( time: Long )( implicit tx: S#Tx ) : A
   def changed: EventLike[ S, Bi.Update[ S, A ], Bi[ S, A ]]
}

BiVar
   setAt( time: Long, value: A )
   getAt( time: Long )

:::::::::::::::

Proc {
   controls
}

maxWaitSpan = p.controls.foldLeft( Span.from( now )) { case ((span, _), min) => min intersect span }

:::::::::::::::

actor {
   loopWhile( isRunning ) {
      reactWithin ( ... )
         case TIMEOUT => advance( logicalTargetTime )
         case x => ...
      }
   }
}

:::::::::::::::

- proc's do not come into existence outside-time; for an auralpresentation, the time at which they are added or removed from the group matters
- therefore, ProcGroup should be bitemporal as well
- if not, it would mean that the transport needs to iterate over all procs no matter when they have been created, to gather the next interval
- it should thus be modelled similar to Inst.Var (formerly BiExpr.Var); but must be capable of having an iterable as its value
- clearly, the plain skiplist doesn't work, since we will need to iterate on its ordering domain and detect incremental changes (proc removed, proc added)

- first idea: use a 2D octree with one axis for start time, one for stop time; values must be able to accomodate multiple procs!
  ; possible disadvantage: half of the space will be unused (since start <= stop); must be possible to represented open intervals