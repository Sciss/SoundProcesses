[2 Apr 2012, 09:05'09.398] Confluent - txn flush write Leaf(Proc<11 @ >,null) for <5 @ 0,2>
[2 Apr 2012, 09:05'09.524] Confluent - txn flush write Expr.Var<6 @ 1,1> for <17 @ 2,2>

Added(Node<1 @ 0,1>,Vector(Proc<11 @ >))
Added(Node<1 @ 0,3>,Vector(Proc<11 @ 2,2>))

____PAPER____ access freqVar
[2 Apr 2012, 09:05'09.695] Confluent - Var(<10 @ 0,0>) get
[2 Apr 2012, 09:05'09.695] Confluent - txn get' <10 @ 0,3,4,4>
[2 Apr 2012, 09:05'09.695] Confluent - txn readID <6 @ 1,3,4,4>
[2 Apr 2012, 09:05'09.695] Confluent - txn read Var(<7 @ 1,3,4,4>)
[2 Apr 2012, 09:05'09.695] Confluent - txn read Var[Int](<8 @ 1,3,4,4>)
[2 Apr 2012, 09:05'09.695] Confluent - txn read Var(<9 @ 1,3,4,4>)

::::::::::::::::::::::::::

theoretically

p1 = proc<0,1>
fr = var<1,1>
  p1.freq<1,1> <-- fr<1,1>
  fr.children<1,1> = Seq( p1.freq<1,1> )

:::
meld
p1 = proc<0,1,3,3>
p2 = proc<0,2,3,3>
fr.children unchanged!

thus when set

///////////////////// fr.freq<1,1,3,4>.set( x )

p1.freq := freqVar * 1.4

what happens is that first
- p1.freq(ref) removes itself from freqVar
- and that erases the reference to p2 as well

[2 Apr 2012, 09:05'09.562] Confluent - Var(<7 @ 1,2>) set Vector() // freq(children) = Nil  (-= proc.freq)

note that in 0,2 we would still find proc<0,2>.freq for freq(children)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

